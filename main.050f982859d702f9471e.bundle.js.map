{"version":3,"file":"main.050f982859d702f9471e.bundle.js","sources":["webpack:///./src/intersection.js"],"sourcesContent":["// @flow\nimport invariant from 'invariant'\n\ntype Callback = (inView: boolean, intersectionRatio: number) => void\n\ntype Instance = {\n  callback: Callback,\n  visible: boolean,\n  options: IntersectionObserverOptions,\n  observerId: ?string,\n  observer: ?IntersectionObserver,\n}\n\nconst INSTANCE_MAP: Map<HTMLElement, Instance> = new Map()\nconst OBSERVER_MAP: Map<?string, IntersectionObserver> = new Map()\n\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\nexport function observe(\n  element: HTMLElement,\n  callback: Callback,\n  options: IntersectionObserverOptions = {},\n  rootId?: string,\n) {\n  // Validate that the element is not being used in another <Observer />\n  invariant(\n    !INSTANCE_MAP.has(element),\n    \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\",\n    element,\n  )\n  // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n  if (!options.threshold) options.threshold = 0\n\n  const { root, rootMargin, threshold } = options\n  if (!element || !callback) return\n  let observerId = rootMargin\n    ? `${threshold.toString()}_${rootMargin}`\n    : threshold.toString()\n\n  if (root) {\n    observerId = rootId ? `${rootId}_${observerId}` : null\n  }\n\n  let observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options)\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance)\n  }\n\n  const instance: Instance = {\n    callback,\n    visible: false,\n    options,\n    observerId,\n    observer: !observerId ? observerInstance : undefined,\n  }\n\n  INSTANCE_MAP.set(element, instance)\n\n  observerInstance.observe(element)\n\n  return instance\n}\n\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\nexport function unobserve(element: ?HTMLElement) {\n  if (!element) return\n  const instance = INSTANCE_MAP.get(element)\n\n  if (instance) {\n    const { observerId, observer } = instance\n    const observerInstance = observerId\n      ? OBSERVER_MAP.get(observerId)\n      : observer\n\n    if (observerInstance) {\n      observerInstance.unobserve(element)\n    }\n\n    // Check if we are still observing any elements with the same threshold.\n    let itemsLeft = false\n    if (observerId) {\n      INSTANCE_MAP.forEach((item, key) => {\n        if (item && item.observerId === observerId && key !== element) {\n          itemsLeft = true\n        }\n      })\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect()\n      OBSERVER_MAP.delete(observerId)\n    }\n\n    // Remove reference to element\n    INSTANCE_MAP.delete(element)\n  }\n}\n\n/**\n * Destroy all IntersectionObservers currently connected\n **/\nexport function destroy() {\n  OBSERVER_MAP.forEach(observer => {\n    observer.disconnect()\n  })\n\n  OBSERVER_MAP.clear()\n  INSTANCE_MAP.clear()\n}\n\nfunction onChange(changes) {\n  changes.forEach(intersection => {\n    const { isIntersecting, intersectionRatio, target } = intersection\n    const instance = INSTANCE_MAP.get(target)\n\n    // Firefox can report a negative intersectionRatio when scrolling.\n    if (instance && intersectionRatio >= 0) {\n      const options = instance.options\n\n      let inView = false\n\n      if (Array.isArray(options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        inView = options.threshold.some(threshold => {\n          return instance.visible\n            ? intersectionRatio > threshold\n            : intersectionRatio >= threshold\n        })\n      } else if (options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        inView = instance.visible\n          ? intersectionRatio > options.threshold\n          : intersectionRatio >= options.threshold\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        inView = inView && isIntersecting\n      }\n\n      instance.visible = inView\n      instance.callback(inView, intersectionRatio)\n    }\n  })\n}\n\nexport default {\n  observe,\n  unobserve,\n  destroy,\n}\n"],"mappings":"AAaA","sourceRoot":""}